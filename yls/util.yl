; ==============================
; = Define Utility Functions
; ==============================
(defun ut.bsort (cmp L)
"ut.bsort <cmp func> <list exp>
    -sort by using bubble sort alorithm (descending order)
     NOTE!: Passed list itself is changed! - sorted.
    @cmp func [Symbol]:   function used to compare.
                          function should be like '(<func> e1 e2)'.
                          This should return 'not nil' if 1st parameter is greater than 2nd parameter, otherwise nil.
    @list exp [list]:     list expression.
"
    (let ( (etmp '()) (I L) (J '()) )
        (while (not (null (cdr I)))
            (set 'J L)
            (while (not (null (cdr J)))
                (cond 
                    ( (eq '() (cmp (car J) (cadr J)))
                        (progn
                            (set 'etmp (car J))
                            (setcar J (cadr J))
                            (setcar (cdr J) etmp))))
                (set 'J (cdr J)))
            (set 'I (cdr I)))
        L))

(defun ut.pair.add (PAIR key value)
"ut.pair.add <pair> <key> <value>
    -add pair data to the pair list at the first position.
     This returns original value if fail, otherwise newly updated pair.
    @pair: Pair --> ((x X)(y Y)...)
"
    (cond ((eq PAIR '())
              (cons (list key value) '()))
          ('t
              (append (cons (list key value) '()) PAIR))))

(defun ut.pair.is-in (PAIR key)
"ut.pair.is-in <pair> <key>
    -check whether <key> is in the pair or not.
     nil is returns if cannot be found. Otherwise <value> nil is returned.
"
    (cond ((null PAIR) '())
          ((equal key (caar PAIR)) 't)
          ('t (ut.pair.is-in (cdr PAIR) key))))

(defun ut.pair.del (PAIR key)
"ut.pair.del <pair> <key>
    -delete pair data whose key is <key>.
     If there is more than one, all are deleted.
    @return : updated pair.
"
    (cond ((null PAIR) '())
          ((equal key (caar PAIR))
              (ut.pair.del (cdr PAIR) key))
          ('t 
              (cons (car PAIR) (ut.pair.del (cdr PAIR) key)))))

(defun ut.pair.get (PAIR key)
"ut.pair.get <pair> <key>
    -find and get matching value.
     @return: nil if fails.
"
    (cond ((null PAIR) '())
          ((equal key (caar PAIR)) (cadar PAIR))
          ('t (ut.pair.get (cdr PAIR) key))))


(defun ut.pair.size (PAIR)
"ut.pair.size <pair>
    -return number of pairs
"
    (list-length PAIR))