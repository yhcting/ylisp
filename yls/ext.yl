; extention of base lisp... This should be interpreted after loading string library.

(defun pr? (PAIR key)
"pr? <pair> <key>
    -check whether <key> is in the pair or not.
     nil is returns if cannot be found. Otherwise <value> nil is returned.
"
    (cond ((null PAIR) '())
          ((equal key (caar PAIR)) 't)
          ('t (pr? (cdr PAIR) key))))

(defun pr- (PAIR key)
"pr- <pair> <key>
    -delete pair data whose key is <key>.
     If there is more than one, all are deleted.
    @return : updated pair.
"
    (cond ((null PAIR) '())
          ((equal key (caar PAIR))
              (pr- (cdr PAIR) key))
          ('t 
              (cons (car PAIR) (pr- (cdr PAIR) key)))))

(defun pr+ (PAIR key value)
"pr+ <pair> <key> <value>
    -add pair data to the pair list at the first position.
     This returns original value if fail, otherwise newly updated pair.
    @pair: Pair --> ((x X)(y Y)...)
"
    (cond (   (equal PAIR '())
              (cons (list key value) '()))
          (   't
              (progn
                  (cond 
                      (   (pr? PAIR key) 
                          (append (cons (list key value) '()) (pr- PAIR key)))
                      (   't
                          (append (cons (list key value) '()) PAIR)))))))

(defun pr* (PAIR key)
"pr* <pair> <key>
    -find and get matching value.
     @return: nil if fails.
"
    (cond ((null PAIR) '())
          ((equal key (caar PAIR)) (cadar PAIR))
          ('t (pr* (cdr PAIR) key))))


(defun pr-from-list (P L V)
"pr-from-list <pair> <key-list> <value>
    -make and append initialized pair from key-list (reverse order)
"
    (cond 
        (   (not (null L))
            (pr-from-list (pr+ P (car L) V) (cdr L) V) )
        ('t P)))


; two different implementations of defstruct
(mset defstruct
    (mlambda (name SLOTS)
        (let ( (rf '()) )
            (defun rf (st S) ""
                (cond ((not (null S))
                    (progn
                        (f-mset (concat st '. (car S) '*)
                            (list 'mlambda '(inst) (list 'trie-get 'inst (list 'car (list 'quote S)))))
                        (f-mset (concat st '. (car S) '+)
                           (list 'mlambda '(inst val) (list 'trie-insert 'inst (list 'car (list 'quote S)) 'val)))
                        (rf st (cdr S))))))
            (f-mset (concat 'make- 'name)
                '(lambda () (trie-create (pr-from-list '() 'SLOTS ''()))))
            (rf 'name 'SLOTS)))
"defstruct <name> <slots> ")

; ---
; Below 'defstruct' is implemented by using 'list'
; It's very good to understand and lisplike implementation.
; But, its slow for large structure...
; ---
;(mset defstruct
;    (mlambda (name SLOTS)
;        (let ( (rf '()) )
;            (defun rf (st S) ""
;                (cond ((not (null S))
;                    (progn
;                        (f-mset (concat st '. (car S) '*)
;                            (list 'mlambda '(inst) (list 'pr* 'inst (list 'car (list 'quote S)))))
;                        (f-mset (concat st '. (car S) '+)
;                            (list 'mlambda '(inst val) (list 'set ''inst (list 'pr+ 'inst (list 'car (list 'quote S)) 'val))))
;                        (rf st (cdr S))))))
;            (f-mset (concat 'make- 'name)
;                '(lambda () (pr-from-list '() 'SLOTS ''())))
;            (rf 'name 'SLOTS)))
;"defstruct <name> <slots> ")))


