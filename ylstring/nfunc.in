/*****************************************************************************
 *    Copyright (C) 2010 Younghyung Cho. <yhcting77@gmail.com>
 *    
 *    This file is part of YLISP.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU Lesser General Public License as
 *    published by the Free Software Foundation either version 3 of the 
 *    License, or (at your option) any later version.
 *    
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU Lesser General Public License 
 *    (<http://www.gnu.org/licenses/lgpl.html>) for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *****************************************************************************/



NFUNC(length,                "s.length",               ylaif_nfunc(),
    "s.length <symbol> : [Double]\n"
    "    -return length of symbol\n"
    "    @symbol [Symbol]\n")

NFUNC(itos,                  "s.itos",                 ylaif_nfunc(),
    "s.itos <value> : [Symbol]\n"
    "    -convert interger part of double to symbol - fraction is ignored\n"
    "    @<value> [Double]\n"
    "    *ex\n"
    "        (s.itos 12.78); => 12\n")

NFUNC(dtos,                  "s.dtos",                 ylaif_nfunc(),
    "s.dtos <value> : [Symbol]\n"
    "    -convert double to symbol\n"
    "    @<value> [Double]\n"
    "    *ex\n"
    "        (s.dtos 12.78); => 12.78\n")

NFUNC(btos,                  "s.btos",                 ylaif_nfunc(),
    "s.btos <value> : [Symbol]\n"
    "    -convert binary to human-readable symbol\n"
    "    @<value> [Binary]\n"
    "    *ex\n"
    "        !Not Tested YET!\n")

NFUNC(split_to_line,         "s.split-to-line",        ylaif_nfunc(),
    "s.split-to-line <text> : <list exp>\n"
    "    -return symbol list. Each symbol contains one-line-string.\n"
    "     line-feed and carrage return are removed.\n"
    "    @text [Symbol]\n"
    "    @return:         list of symbols\n"
    "    *ex\n"
    "        (set 'r (s.split-to-line '\"1st line\\n2nd line\\n\"))\n"
    "        (print (car r));   => '1st line'\n"
    "        (print (cadr r));  => '2nd line'\n")

NFUNC(at,                    "s.at",                   ylaif_nfunc(),
    "s.at <string> <index> : [Symbol]\n"
    "    -get character at the specific index.\n"
    "    @index [Double] :\n"
    "    @return         : one-character-symbol\n")

NFUNC(compare,               "s.compare",              ylaif_nfunc(),
    "s.compare <str1> <str2>: [Double]\n"
    "    -Compare two strings lexicographically\n"
    "    @return:    same with 'strcmp'\n")

NFUNC(end_with,              "s.end-with",             ylaif_nfunc(),
    "s.end-with <string> <suffix> : [t/nil]\n"
    "    -Tests if <string> ends with specific suffix.\n")

NFUNC(start_with,            "s.start-with",           ylaif_nfunc(),
    "s.start-with <string> <prefix> (<from index>): [t/nil]\n"
    "    -Tests if this <string> starts with the specified <prefix> beginning a specified <from index>.\n"
    "    @from index [Double] :\n")

NFUNC(index_of,              "s.index-of",             ylaif_nfunc(),
    "s.index-of <string> <str> (<from index>): [Double/nil]\n"
    "    -Returns the index within <string> of the first occurrence of the <str>, starting the search forward at the <from index>\n"
    "    @return [Double]     : nil if fail to search. Otherwise index.\n"
    "    @from index [Double] :\n");

NFUNC(last_index_of,          "s.last-index-of",       ylaif_nfunc(),
    "s.last-index-of <string> <str> (<from index>): [Double/nil]\n"
    "    -Returns the index within <string> of the last occurrence of the <str>, starting the search backward from the <from index>\n"
    "    @from index [Double] :\n"
    "    @return: nil if fails\n")

NFUNC(replace,                "s.replace",             ylaif_nfunc(),
    "s.replace <string> <old> <new>: [Symbol]\n"
    "    -Returns a new string resulting from replacing all occurrences of <old> in <string> with <new>.\n"
    "     If fails to match, original string is returned.\n")

NFUNC(substring,              "s.substring",           ylaif_nfunc(),
    "s.substring <string> <begin index> (<end index>): [Symbol]\n"
    "    -Returns a new string that is a substring of this string.\n"
    "    @begin index [Double] : inclusive\n"
    "    @end index [Double]   : exclusive\n")

NFUNC(to_lower_case,          "s.to-lower-case",       ylaif_nfunc(),
    "s.to-lower-case <string>: [Symbol]\n"
    "    -Converts all of the characters in this string to lower case - assume ASCII\n");

NFUNC(to_upper_case,          "s.to-upper-case",       ylaif_nfunc(),
    "s.to-upper-case <string>: [Symbol]\n"
    "    -Converts all of the characters in this string to upper case - assume ASCII\n");

NFUNC(trim,                   "s.trim",                ylaif_nfunc(),
    "s.trim <string>: [Symbol]\n"
    "    -Removes white space from both ends of <string>\n")
